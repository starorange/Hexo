[{"title":"Vue的移动端适配","date":"2023-03-15T11:46:25.000Z","url":"/2023/03/15/2/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["移动端","/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"]],"categories":[["技术总结","/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"]],"content":"方案一rem：相对单位，1rem &#x3D; 根元素1 font-size大小如果根元素 &lt; html style&#x3D;”font-size: 20px;” &gt; ，1rem &#x3D; 20px ，2rem &#x3D; 40px如果根元素 &lt; html style&#x3D;”font-size: 30px;” &gt; ，1rem &#x3D; 30px ，2rem &#x3D; 60px可以给 &lt; html &gt; 设置font-size值为设备宽度的1&#x2F;10设备宽为375px， &lt; html &gt; 的font-size为37.5px，1rem &#x3D; 37.5px设备宽为414px， &lt; html &gt; 的font-size为41.4px，1rem &#x3D; 41.4px设备宽为820px， &lt; html &gt; 的font-size为82px，1rem &#x3D; 82px后续只需要使用rem为单位即可 main.js view&#x2F;About.vue 设备宽为375px， &lt; html &gt; 的font-size为37.5px，1rem = 37.5px4 * 37.5 &#x3D; 150，&#x3D;&gt; 150 &#x2F; 375， &#x3D;&gt; 2 &#x2F; 5，色块占设备宽度的2&#x2F;5 设备宽为414px， &lt; html &gt; 的font-size为41.4px，1rem = 41.4px 4 * 41.4 &#x3D; 165.6，&#x3D;&gt; 165.6 &#x2F; 414， &#x3D;&gt; 2 &#x2F; 5，色块占设备宽度的2&#x2F;5 方案二1.amfe-flexibleamfe-flexible是配置可伸缩布局方案，主要是将1rem设为viewWidth&#x2F;10。 2.postcss-pxtorempostcss-pxtorem是postcss的插件，用于将像素单元生成rem单位。 3.移动端适配方案首先安装amfe-flexible和postcss-pxtoremnpm install amfe-flexible --savenpm install postcss-pxtorem --save 使用方法main.js 中引入import &#39;amfe-flexible&#39; 在根目录下新增配置文件 postcss.config.js propList：表示哪些属性的px转换为rem， ‘*’ 表示所有属性都转换 rootValue：转换参考值，写UI设计稿宽度的1&#x2F;10，假设UI设计稿宽度是750px所以写75，如UI设计稿是375px则写37.5 假设UI设计稿宽度是750px，色块设计稿标注是150px，此时色块在设计稿占比是150 &#x2F; 750 &#x3D; 1 &#x2F; 5 转换规则150 &#x2F; 配制的参考值，配制的参考值是75，也就是150 &#x2F; 75，得到结果为2，就是2rem设备宽为375px，amfe-flexible会设置1rem &#x3D; 37.5px，所以2rem实际大小就是75px设备实际显示75 &#x2F; 375 &#x3D; 1 &#x2F; 5，色块占设备宽度的1&#x2F;5，与UI设计稿色块占比保持一致 设备宽为414px，amfe-flexible会设置1rem &#x3D; 41.4px，所以2rem实际大小就是82.8px 设备实际显示82.8 &#x2F; 41.4 &#x3D; 1 &#x2F; 5，色块占设备宽度的1&#x2F;5，与UI设计稿色块占比保持一致 Vant兼容问题如果使用了vant组件库，vant的设计稿是根据375px去设计的，为了避免冲突需要单独设置下postcss.config.js 方案二使用postcss-px-to-viewport在开发中可以直接使用PX单位，打包自动转化成viewport npm install postcss-px-to-viewport 配置postcss.config.jsviewportWidth：设计稿的视口宽度 转换规则假设UI设计稿宽度是750px，色块设计稿标注是300px，此时色块在设计稿占比是300 &#x2F; 750 &#x3D; 2 &#x2F; 5 300 &#x2F; viewportWidth，配制的参考值是750，300 &#x2F; 750得到结果为2&#x2F;5，设备实际显示色块宽度占比就是2&#x2F;5也就是40vw，与UI设计稿占比一致"},{"title":"Vuex总结","date":"2023-03-15T11:46:25.000Z","url":"/2023/03/15/3/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["Vuex","/tags/Vuex/"]],"categories":[["技术总结","/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"],["教程","/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%95%99%E7%A8%8B/"]],"content":" Vuex是基于Vue的响应式原理基础，所以无法拿出来单独使用，必须在Vue的基础之上使用。1.Vuex使用相关解析 main.js store.js 2.Vuex原理解析实现 首先我们要清楚Vuex的定位，它是一个插件。且必须基于之上Vue来使用，为什么这么说呢，因为他的数据响应是基于Vue的。 1.Vuex核心概念① state 驱动应用的数据源。② Getter getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生变化了改变才会被重新计算（由此你是不是想到了计算属性，对完全可以这么理解）。③ Mutation 进行Vuex中store状态的更改，也是官方规定更改状态的唯一途径。④ Action 进行异步操作的场所，但是更改数据还是需要commit提交。⑤ Module 单一状态树对象比较复杂，Vuex允许我们将Store分割成多模块，每个模块拥有自己独立的内容。 2.实现Vuexstore.js 先创建一个入口文件 这边会暴露出一个install方法，Vue.sue()的时候会调用它。还有一个提供实例化的Store类 3.总结1、作为插件引入，执行install方法调用Vue.mixin在Vue全局生命周期混入一个方法，将Vuex中定义的数据源挂载到this.$store,即当前组件的实例上。 2、state 直接new Vue实例，将数据源传入。完成数据源响应式操作。 3、getters 递归遍历用户传入的getters对象，拿到每个里面每一个函数，通过Object.definedProperty属性处理。当get函数读取compile，触发get调用相应函数（函数内部自动传入当前数据源state作为参数），完成数据响应。 4、mutations 递归遍历用户传入的mutations 对象，将相同名称下的函数都挂载到当前实例的mutations数组中，完成订阅。commit的时候拿到对应的函数名称进行遍历mutations数组调用对应名称函数，完成发布。 5、actiosns 操作和mutations一样。 6、module 是将用户传入的数据进行格式化，格式化好以后执行上面的安装模块的方法。具体查看上方installModule方法的详细操作。"},{"title":"Vue组件传参总结","date":"2023-03-14T16:00:00.000Z","url":"/2023/03/15/4/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"]],"categories":[["技术总结","/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"],["教程","/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%95%99%E7%A8%8B/"]],"content":" 父传后代父传子 父组件引入子组件，绑定数据 &lt;zi :msg=&quot;msg&quot;/&gt; 子组件通过props来接受 总结：这种传递方式很方便，但是父传孙子辈就很麻烦 （父&#x3D;&gt;子&#x3D;&gt;孙） 子组件不能直接修改父组件的数据 子组件直接使用父组件的数据子组件通过：this.$parent.msg使用父组件元素孙子组件通过：this.$parent.$parent.msg使用子组件可以通过this.$parent快速找到父元素 这种方式可以直接修改父组件的值 依赖注入 provide/inject 父组件 后辈组件inject:[&#39;msg1&#39;] 总结：只能从父辈向后辈传递，不用一级一级传递直接用，不能向兄弟组件传递。 后代向父代传递一般情况下，后代向父代传递，在交互时，用的较多 使用 $emit 子组件 父组件 $children在父组件中可以直接使用,获取子组件的值this.$children.str2 $ref&#x2F;$refs在父组件中可以直接使用、修改,子组件的值 修改值 this.$refs.child.str2=&#39;xxxx&#39;"},{"title":"Vue2与Vue3的区别","date":"2022-07-13T12:46:25.000Z","url":"/2022/07/13/1/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"]],"categories":[["技术总结","/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"]],"content":"vue2和vue3双向绑定的原理产生了改变 vue2的双向数据绑定是利用了es5 的一个API Object.definepropert() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行处理。 vue3 中使⽤了 ES6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。 与vue2相比Proxy的优势 1.defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 2.可以监听数组，不⽤再去单独的对数组做特异性操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美⽀持对数组的监听。 Vue3支持composition API Vue2 是选项API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。 Vue3 组合式API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。 生命周期的变化 setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和methodonBeforeMount() : 组件挂载到节点上之前执行的函数。onMounted() : 组件挂载完成后执行的函数。onBeforeUpdate(): 组件更新之前执行的函数。onUpdated(): 组件更新完成之后执行的函数。onBeforeUnmount(): 组件卸载之前执行的函数。onUnmounted(): 组件卸载完成后执行的函数 若组件被包含，则多出下面两个钩子函数。onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。 "}]